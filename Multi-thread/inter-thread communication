本章主要讲了线程间的通信，就是解决了线程之间进行消息传递的方式，主要是两种通信：数据传递通信以及互相唤起。

1、等待/通知机制：
   主要通过wait()方法和notify和notifyAll()实现的，wait()方法是释放锁的，而且在调用wait()方法之前需要获取到该对象的对象级别的锁，当执行wait()
方法之后就会释放掉自己所拥有的所有锁，并挂起。方法notify和notifyAll两个方法，是在方法执行完完成自己的任务之后才释放。总结一句话就是wait()方法
使线程停止运行，而notify是负责唤起线程。通时被唤起的线程一定是拥有同一对象监视器的线程。同时在wait之后不可以添加终端也就是不可以继续执行interupt方法

2、在通知的时候一定要注意唤起的时间，因为可能会出现因为过早唤起释放锁造成数据的问题，以及假死的状态。

3、在wait中最好都选择使用while进行条件的判断，防止出现逻辑的错误。

4、生产者/消费者进行操作的时候一定要注意使用notifyAll方法进行唤起防止一直唤起的是自己的同类造成假死的状态。

5、管道流----用于线程之间的数据传输。
  字节流----PipedInputStreamh和PipedOutputStream
  字符流----PipedReader和PipedWriter
  和之前的IO流没有什么区别，唯一的区别就是需要将一个输入流和输出流进行连接，例如：input.connect(out)

6、join方法，等待线程对象方法销毁，就是类似于主线程等待子线程执行完消息之后继续执行之后的代码。同时由于join方法的内部实现是wait方法因此，具有释放所的特性。

7、ThreadLocal方法，就是本地线程，类似于给每一个线程分配了自己的私有存储变量的地方。并且每一个线程之间互不干扰。通过get和set进行存取。

8、使用localhost方法可以通过重写initialValue方法设置初值。

9、子类也可以继承来自父进程的值，通过使用InheritableThreadLocal类可以继承父类的值，同时可以通过重写childValue方法，使子类可以重写从父类继承的值
