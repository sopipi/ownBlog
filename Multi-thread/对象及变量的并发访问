自己看书的总结：
1、由于方法内部的变量是私有的，所以方法中的变量不存在非线程安全问题，永远都是线程安全的。

2、两个线程访问同一个没有同步的方法，可能会出现交叉或者覆盖的线程安全问题，可以通过加关键字synchoronized进行同步。多个线程访问同一个对象实例中的
同步方法时一定是线程安全的。关键字synchoronized取得的对象锁，而不是把一段代码或者方法当作锁，那个方法先执行到带synchorized关键字的方法
，就先获取到该对象的锁，其他的就只能等待。而当多个线程访问多个对象，就会产生多个锁。
而当线程A获取到某一对象的锁对象后，其他线程 可以异步调用非同步的方法，但是要调用同步（关键字synchoronized修饰）的方法，就只能排队执行。

3、synchronized锁具有锁重入的功能，也就是说在使用synchronized时，当一个线程得到一个对象锁之后，再次请求此对象锁的时候是可以得到该对象的锁的。
，就是说一个synchronized线程中调用其他的加锁对象是可以继续调用的，也就是可以继续得到锁的，同时锁重入也具有继承性，子类可以通过可重入锁进入到父类的
同步方法。

4、当锁因为异常停止的时候，会释放其所持有的全部的锁。

5、同步方法不具有继承性，子类中的与父类同名方法需要重新添加synchtonsized进行修饰。

6、由于synchronsized只能修饰对象或者方法，执行效率慢。可以通过使用代码块的方法进行改进，同时代码块依旧是对象锁。只要是使用的是同一个“对象监视器”
就是同步的，就会满足2的说法。持有不同的对象监视器就是异步执行的。

7、同时synchronsized还可以用在static方法上，但是，就会对当前的class类柴油锁，会对class类的所有对象实例起作用。

8、java中string若是直接赋值，那么值一样就是同一个对象，这是JVM String的常量池特性所致，若是新建一个String实例，就会是两个对像。所以在代码块中若是
对String对象上锁，就会容易出现死锁。

9、synchorized关键字还涉及到内置类的使用。内置类也就是在一个类的内部包含另一个类，包括静态内置类和非静态内置类。非静态内置类需要使用下列语句进行创建
内部类名 命名 = 外部类名.new 内部类名()。也有一个静态内置类，也就是用static进行修饰的类名，此时是当做；两个类进行看待的，所以加了synchronized进行修饰
就当作两个类进行看待。

10、只要对象不变化，即使属性进行了变化，运行的结果也是不变的。就是说synchronized进行修饰的只要对象内存不变的情况下，就不会改变锁的性质

11、volatile关键字，作用，强制线程从公共区域进行选择变量的值，而不从自己的私有变量中进行选取。从而实现线程之间的数据可见性。但是ishikawa非原子性的。

12、在jvm中将其设置为-server就会强制线程只能从私有栈中选择变量。

13、synchronized关键字除了具有同步功能之外，还具有volatile的可见性，因为另一个线程想要访问数据的时候，就需要等待前一个线程执行完
之后才可以取得，因此就保证了可见性和同步性。

14、原子类，例如AtomicInteger原子类，在原子类内部是线程安全的，但涉及到逻辑的问题是依旧需要加锁，因为是随机执行的，所以就需要加锁，保证线程安全。
