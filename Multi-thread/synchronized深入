功能：一句话描述synchtronized的作用：能够保证在同一时刻最多只有一个线程执行该段代码，一大到并发安全的作用。

使用方法：对象锁：代码块/直接修饰普通方法
      类锁：synchronized修饰静态方法；.class静态代码块
多线程访问同步方法的7种情况：
1.两个线程同时访问一个对象实例的同步方法：相互等待，锁生效。
2.两个线程访问的两个对象实例的同步方法：相互没有影响，并行（异步）执行。
3.两个线程访问的是synchronized的静态方法：即使实例不同，锁也生效。
4. 同时访问同步方法和非同步方法：非同步方法不受同步方法影响。
5. 访问同一个对象实例的不同的普通(非static)同步方法：因为默认锁对象是this，所以锁生效，会并行执行。
6. 同时访问静态synchronized和非静态synchronized方法：因为static synchronized的锁是*.class，而non-static synchronized的锁是this，所以并不相互冲突，可以并行执行。
7.方法抛出异常后，会释放锁：RuntimeException()不用强制捕获
主要考虑的是synchronized是加锁的对象还是类

性质：
可重入：指的是同一线程的外层函数获得锁之后，内层函数可以直接再次获取锁。
好处：避免死锁，提升封装性

部分原理介绍：
加锁和释放锁原理：现象、时机、深入JVM看字节码
    现象：每一个类的实例对应着一把锁，而每一个synchronized方法都必须首先获得调用该方法的类的实例的锁，才能执行。否则线程就会阻塞，而方法一旦执行，就会独占这把锁，直到该方法返回，或者抛出异常，才将锁释放。释放之后，其他被阻塞的线程才能获得这把锁，重新进入可执行的状态。
    获取锁和释放锁的时机：内置锁
    字节码：反编译 看monditor指令
    javac命令进行编译文件，javap -verbose反编译文件
    monditorenter进行锁计数器+1，monditiorexit进行释放锁
可重入原理：加锁次数计数器
    1、JVM负责跟踪对象被加锁的次数；
    2、有个monitor计数器，线程第一次给对象加锁的时候，计数变为1.每当这个相同的线程在此对象上再次获得锁时，计数会递增。
    3、任务结束离开，则会执行monitorexit，计数递减，直到完全释放
保证可见性的原理：内存模型
    类似于volatile，强制从共享区进行取值，而不是从自己的私有内存
synchronized的缺陷
    效率低：锁的释放情况少，试图获得锁时不能设定超时，不能中断一个正在试图获得锁的线程
    不够灵活（读写锁更灵活）：加锁和释放锁的时机单一，每个锁仅有单一的条件（某个对象），可能是不够的
    无法知道是否成功获取到锁

相关的面试题：
1、使用注意点：锁对象不能为空，锁的信息是保存在对象头中的；作用域不宜过大、影响性能；避免死锁避免死锁
2、如何选择Lock和synchronized关键字
    1）建议都不使用，可以使用java.util.concurrent包中的Automic类(原子类)、countDown等类
    2）优先使用现成工具，如果没有就优先使用synchronized关键字，好处是写劲量少的代码就能实现功能。如果需要灵活的加解锁机制，则使用Lock接口
